<!DOCTYPE html>
<html>
<head>
<title>TTF-json</title>
<script src="ttf-json.js">
</script>
<script>
var fileReader = new FileReader();
var filename;
var ttf_json;
var ttf_jq_json;

function set_status(id, stat)
{
  document.getElementById(id).innerHTML = stat;
}

function append_status(id, stat)
{
  document.getElementById(id).innerHTML += "<br />" + stat;
}

function downloadURI(uri, name)
{
  var link = document.createElement("a");
  link.download = name;
  link.href = uri;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  delete link;
}

function download1()
{
  const str = ttf_json.toString();
  const bytes = new TextEncoder().encode(str);
  const blob = new Blob([bytes], { type: "application/json;charset=utf-8" });
  let url = URL.createObjectURL(blob);
  let dl_filename = filename + ".json.txt";

  downloadURI(url, dl_filename);
}

function download2()
{
  const str = ttf_jq_json.toString();
  const bytes = new TextEncoder().encode(str);
  const blob = new Blob([bytes], { type: "application/json;charset=utf-8" });
  let url = URL.createObjectURL(blob);
  let dl_filename = filename + ".jq.json.txt";

  downloadURI(url, dl_filename);
}

function convert_to_svg_glyph_curve(curve_json, ABCDEF)
{
  let svg = "";
  let A = 1.0;
  let B = 0.0;
  let C = 0.0;
  let D = 1.0;
  let E = 0.0;
  let F = 0.0;
  if (ABCDEF != undefined) {
    A = ABCDEF.A;
    B = ABCDEF.B;
    C = ABCDEF.C;
    D = ABCDEF.D;
    E = ABCDEF.E;
    F = ABCDEF.F;
  }
  for (let i=0; i<curve_json.length; i++) {
    if (curve_json[i].on_curve) {
      if (i == 0) {
        svg += "M";
      } else {
        svg += "L";
      }
      svg += A * curve_json[i].xy[0] + B * curve_json[i].xy[1] + E;
      svg += " ";
      svg += C * curve_json[i].xy[0] + D * curve_json[i].xy[1] + F;
      svg += " ";
    } else {
      let ip1 = (i + 1) % curve_json.length;
      svg += "Q";
      svg += A * curve_json[i].xy[0] + B * curve_json[i].xy[1] + E;
      svg += " ";
      svg += C * curve_json[i].xy[0] + D * curve_json[i].xy[1] + F;
      svg += " ";
      svg += A * curve_json[ip1].xy[0] + B * curve_json[ip1].xy[1] + E;
      svg += " ";
      svg += C * curve_json[ip1].xy[0] + D * curve_json[ip1].xy[1] + F;
      svg += " ";
    }
  }
  return svg;
}

function convert_to_svg_glyph(glyph_jsons, idx)
{
  let glyph_json = glyph_jsons[idx]

  if (glyph_json == null) {
    return "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"50\" height=\"50\"></svg>";
  }

  let svg = "<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"50\" height=\"50\"><g transform=\"translate(10, 38) scale(0.02, -0.02)\"><path d=\"";

  if (!Array.isArray(glyph_json)) {
    /* composite glyph */
    let subglyfs = glyph_json.subglyfs;
    for (let i=0; i<subglyfs.length; i++) {
      subglyf = subglyfs[i];
      if (!subglyf.ARGS_ARE_XY_VALUES) {
        alert("!ARGS_ARE_XY_VALUES Unsupported");
      }
      sub_glyph_json = glyph_jsons[subglyf.glyphIndex];
      if (!Array.isArray(sub_glyph_json)) {
        alert("Nested composite unsupported");
      }
      let ABCDEF = {
        A: subglyf.A, B: subglyf.B, C: subglyf.C,
        D: subglyf.D, E: subglyf.E, F: subglyf.F
      };
      for (let j=0; j<sub_glyph_json.length; j++) {
        svg += convert_to_svg_glyph_curve(sub_glyph_json[j], ABCDEF)
      }
    }
  } else {
    for (let i=0; i<glyph_json.length; i++) {
      svg += convert_to_svg_glyph_curve(glyph_json[i]);
    }
  }

  return svg + "Z\"/></g></svg>";
}

function convert_to_svg()
{
  let json = JSON.parse(ttf_jq_json);
  let table_el = window.document.getElementById("glyphs");
  let table_tr_el = document.createElement("tr");
  for (let i=0; i<json.length; i++) {
    if (i != 0 && (i % 10) == 0) {
      table_el.appendChild(table_tr_el);
      table_tr_el = document.createElement("tr");
    }
    let table_td_el = document.createElement("td");
    let svg = convert_to_svg_glyph(json, i);
    let svg_el = document.createElement("img");
    svg_el.src = "data:image/svg+xml;base64," + btoa(svg);
    table_td_el.appendChild(svg_el);
    table_tr_el.appendChild(table_td_el);
  }
  table_el.appendChild(table_tr_el);
}

function display_svg()
{
    convert_to_svg();
    append_status("status3", "Generated SVG.");
}

function jqconvert()
{
    launch();
    ttf_jq_json = window.document.getElementById("output").innerHTML;
    window.document.getElementById("download2").style.display = "block";
    append_status("status2", "Finished JQ conversion");
    append_status("status3", "Generating SVG...");
    setTimeout(display_svg, 0);
}

function parseFile()
{
    meta = { offset: 0, readbuf: new Uint8Array(fileReader.result), ttf: { } };
    ttf_json = parse(meta);
    window.document.getElementById("download1").style.display = "block";
    window.document.getElementById("input").innerHTML = ttf_json;
    append_status("status", "Parsed file.");
    append_status("status2", "Starting JQ conversion");
    setTimeout(jqconvert, 0);
}

function readFile(input)
{
  let file = input.files[0];
  filename = file.name;
  fileReader.readAsArrayBuffer(file);
  set_status("status", "Loading file...");
  fileReader.onload = function() {
    append_status("status", "Loaded file.");
    append_status("status", "Parsing file...");
    setTimeout(parseFile, 0);
  }

  fileReader.onerror = function() {
    alert(fileReader.error);
  }

}
</script>
</head>
<body>

<div style="display:block">Please feed me a font file.  TTF, OTF.</div>
<input onchange="readFile(this)" type="file" />
<div id="status">
Waiting for file.
</div>
<a id="download1" style="display:none" href="javascript:download1()">Download parsed JSON</a>
<div style="display:block" id="content">
<div id="status2">
</div>
<a id="download2" style="display:none" href="javascript:download2()">Download converted JSON</a>
<div id="status3">
</div>

<table id="glyphs" border="1px">
</table>

<div id="ttf-json-zip" style="visibility: hidden">
</div>

<div id="error" style="color:red">
</div>

<div id="input" style="visibility: hidden">
</div>

<div id="query" style="visibility: hidden">
def unroll_flags: .flags | 
    map(  if .REPEAT_FLAG
          then (. as $flag | range(.repeat_count + 1) | $flag)
          else . end
       );

def build_contour_map: .contourEnds |
    { i: [range(1; (. | length) + 1)],
      m: [0,map (. + 1)[]]            } as $j |
    $j.i | map([$j.m[.-1],$j.m[.]]);

def build_lookup: [foreach [0,.[]][] as $pt (0; . + $pt)];

def build_lookup_xy: {x: (.xCoordinates | build_lookup),
                      y: (.yCoordinates | build_lookup) };

def build_intermediate_1: { contour_map: (. | build_contour_map),
                            unrolled_flags: (. | unroll_flags),
                            lookup_xy: (. | build_lookup_xy) };

################################################################################

def build_coordinate_index:
 [ 
  map(  if(.X_SHORT_VECTOR)
        then 1
        else
          if (.X_IS_SAME_OR_POSITIVE_X_SHORT_VECTOR)
          then 0
          else 1 end
        end),

  map(  if(.Y_SHORT_VECTOR)
        then 1
        else
          if (.Y_IS_SAME_OR_POSITIVE_Y_SHORT_VECTOR)
          then 0
          else 1
          end
        end)
  ] | [
        [foreach .[0][] as $i (0; . + $i)],
        [foreach .[1][] as $i (0; . + $i)]
      ];

def on_curve_map: map(.ON_CURVE_POINT);


def build_intermediate_2: { coordinate_index:
                                  (.unrolled_flags | build_coordinate_index),
                            lookup_xy: .lookup_xy,
                            contour_map: .contour_map,
                            on_curve_map: (.unrolled_flags | on_curve_map) };

################################################################################

def avg: [((.[0][0] + .[1][0]) / 2), ((.[0][1] + .[1][1]) / 2)];

def decompress_simple_glyf:
  build_intermediate_1 |
  build_intermediate_2 as $i | 
  [range(($i.coordinate_index[0] | length))] |
  map([$i.lookup_xy.x[$i.coordinate_index[0][.]],
       $i.lookup_xy.y[$i.coordinate_index[1][.]]]) as $coords |
  $i.contour_map | 
  {
    contour_coords: map($coords[.[0]:.[1]]),
    contour_on_curve_map:
        (map($i.on_curve_map[.[0]:.[1]]) | map([.[-1],.[]])),
    contour_on_curve_ranges: map([range(1;(.[1]-.[0]+1))]),
    contour_on_curve_range: [range(. | length)]
  } as $i2 |
  $i2.contour_on_curve_range |
  map(. as $j |
      $i2.contour_on_curve_ranges[$j] |
      map( if ($i2.contour_on_curve_map[$j][.] == false and
               $i2.contour_on_curve_map[$j][.-1] == false)
           then [.-2,.-1],.-1
           else .-1
           end) |
      map(if type == "number"
          then { xy: $i2.contour_coords[$j][.],
                 on_curve: $i2.contour_on_curve_map[$j][.+1] }
          else { xy: ( [$i2.contour_coords[$j][.[0]],
                        $i2.contour_coords[$j][.[1]]] | avg), 
                 on_curve: true }
          end)
      );
                            

.tables.glyf | map(if (type=="object")
                   then
		     if (.numberOfContours != -1)
                     then (. | decompress_simple_glyf)
		     else (.)
		     end
                   else null end)
</div>

<div id="output" style="visibility: hidden">
</div>


<script type="text/javascript">
// WebAssembly module config
var STDOUT = [],
    STDERR = [],
    FILE_DATA = "/tmp/data.json";

var Module = {
  // Don't run main on page load
  noInitialRun: true,

  // Print functions
  print: stdout => STDOUT.push(stdout),
  printErr: stderr => STDERR.push(stderr),

  // When the module is ready
  onRuntimeInitialized: function() {
    //document.getElementById("btnRun").disabled = false;
  }
};

// Utility function to run jq
function jq(jsonStr, query, options)
{
  // Custom jq options.
  // Default = -M = disable colors
  var mainOptions = [ "-M" ];
  if(options != null && options.length > 0)
    mainOptions = mainOptions.concat(options);

  // Create file from object
  FS.writeFile(FILE_DATA, jsonStr);

  // Clear previous stdout/stderr before launching jq
  STDOUT = [];
  STDERR = [];

  // Launch jq's main() function
  mainOptions = mainOptions.concat([ query, FILE_DATA ]);
  Module.callMain(mainOptions);

  // Re-open stdout/stderr after jq closes them
  FS.streams[1] = FS.open("/dev/stdout", "w");
  FS.streams[2] = FS.open("/dev/stderr", "w");

  return {
    stdout: STDOUT.join("\n"),
    stderr: `${STDERR[0]}\n${STDERR[1]}`
  };
}

// Launch jq on current field values
function launch()
{
  var elQuery  = document.getElementById("query"),
      elError  = document.getElementById("error"),
      elData   = document.getElementById("input"),
      elOutput = document.getElementById("output");

  // Call jq
  var out = jq(elData.innerHTML, elQuery.innerHTML);

  // Parse jq errors
  elError.innerHTML = "";
  if(out.stdout != "")
    elOutput.innerHTML = out.stdout;
  else
    elError.innerHTML = out.stderr;
}

// On page load
document.addEventListener("DOMContentLoaded", 
function()
{
  // Launch jq when click button
  // document.getElementById("btnRun").addEventListener("click", launch);
});

</script>
<script src="jq.js">
</script>
</body>
</html>
